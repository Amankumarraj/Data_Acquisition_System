/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include "project.h"
#include "core_cm4.h"

uint32_t adc_val;
uint16_t rx[10];
unsigned int count = 0;

int main(void)
{
    pc2_adc_init();
    GPIO_init();
    uart1_tx_config();
    uart3_rx_config();

    NVIC_EnableIRQ(EXTI15_10_IRQn); // Enable EXTI15_10 interrupt in NVIC
    EXTI_Cnfg();

    while (1)
    {

    }
}


void EXTI15_10_IRQHandler(void)
{
    if (EXTI->PR & (1<<13)) //Check for interrupt in EXTI13 (PC13)
    {
        GPIOA->ODR |=(1<<5); //Turn on LED to indicate start of operation
        uint32_t i=0;
        for(i=0;i<10000;i++);
        GPIOA->ODR &=~(1<<5); // Turn off LED

        start_conversion();
        adc_val =adc_read(); // Read ADC value

        // Transmit starts from USART1
        USART1->DR =adc_val;
        while (!(USART1->SR & (1<<7))); // Wait for transmission to complete

        // Received data by USRT3
        if (USART3->SR & (1<<5))
        {
            rx[count] = USART3->DR;
            if (++count==10)
                count=0; // Reset  if it reaches the max size
        }

        EXTI->PR |=(1<<13); // Clear the interrupt pending bit for EXTI13
    }
}
